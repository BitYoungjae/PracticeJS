<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>191130 코어 자바스크립트 저자직강</title>
</head>

<body>
    <script>
        {
            // DATA TYPE
            /* 식별자와 데이터의 저장을 별개로 한다.
             식별자에 특정 값을 할당시,
             원시형 데이터의 경우 실제 데이터가 저장된 메모리 주소를 식별자명과 함께 기록한다.
             참조형 데이터의 경우 참조형 데이터의 멤버들의 주소목록이 저장된다.
             */
        } {
            // 실행문맥과 렉시컬 환경
            /*
            나의 사견 : 
            코어 자바스크립트는 과거 사양을 기준으로 실행문맥을 설명한다.
            식별자 확인에 있어서 과거의 사양과는 큰 변화가 생겼기 때문에,
            과거의 사양을 기준으로 학습할 경우 이후 블록스코프에 대해 이해할 때 혼란이 생길 수 있다.

            예를 들어 지금 이 주석을 작성하고 있는 위치 역시 별개의 블록으로 묶여있다.
            이 블록 스코프에 대해 종전의 사양으로 식별자 확인 작업을 설명하는 것이 가능할까?

            과거에는 함수에 의해서만 새로운 렉시컬 환경이 생성되었지만,
            ES6 이후부터는 try-catch 블록, 블록구문, 반복문의 각 반복단위, 조건문 내 블록 에서 각각 새로운 렉시컬 환경이 생성된다.

            또한 Variable Environment 역시 과거 var로 선언 되었던 식별자들에 대한 하위 호환을 목적으로 만들어진 객체이다.

            이런 큰 차이점들이 있기 때문에,
            보다 실용적이고 최신 스펙에 가까운 개념을 학습코자한다면 http://ko.javascript.info/ 에 정리된 내용을 추천한다.
            
            실행문맥이나 렉시컬 환경은 ECMASCRIPT 사양 상의 개념이기 때문에, 코드내에서 개발자가 직접 접근할 수 있는 실체가 없다.
            물론 과거 프로토타입의 예처럼 향후 스펙에서 어떤 변화가 있을지는 모르겠다만,
            현재는 엔드포인트의 개발자에게 있어서 추상적인 개념일 뿐이므로
            개괄적으로만 코드의 흐름을 읽을 수 있을 정도로 익혀두는 것이 중요하다.
            */
        } {
            // THIS
            /*
            THIS BINDING CASE들
                * 전역공간에서 : window/global 전역객체
                * 함수 호출시 : window/global 전역객체
                * 메소드 호출시 : 
                    객체 안에 선언 되거나 저장되어있다고 모두 메서드로써 호출되는 것이 아니다.
                    .연산자나 [] 접근법을 활용시 좌변의 객체를 this로 갖는다. 단, 화살표 함수 예외.
                * callback 호출시 : 렉시컬 환경을 따른다.
                * 생성자 함수 호출시 : 새로 생성된 객체.
                * bind나 call apply 사용시 : 화살표 함수는 동작하지 않고,
                function 선언이나 표현식의 경우에 인자로 전달된 객체를 this로 binding 한다.
            */

            // 메소드 호출의 예
            const a = {
                b: {
                    c() {
                        console.log(this);
                    },
                    e: () => {
                        console.log(this);
                    }
                },
                d() {
                    console.log(this);
                }
            };

            const b = a.b;

            a.b.c(); // b 객체를 this로 binding
            b.c(); // 상동
            a.d(); // a 객체를 this로 binding
            b.e(); // 화살표 함수는 this binding을 하지 않는다. 즉 전역객체가 출력.

            (a.b.c.bind(a))(); // bind는 인자로 받은 객체를 this로 binding한 함수를 반환한다.
            a.d.call(a.b); // 인자로 받은 객체를 this로 binding 하여 호출한다. apply와의 차이점은 this 외의 인자를 배열로 받고 안 받고의 차이일 뿐이다.


            // 콜백 호출의 예
            const callback = function () {
                console.log(this);
            };

            const obj = {
                b(cb) {
                    cb(); // 함수로써의 호출과 다름이 없음을 주목하자.
                    cb.call(this); // 이 경우 obj를 출력하게 된다.
                }
            };

            obj.b(callback);

            // 이벤트 호출시
            // 화면의 빨간 상자를 클릭해보라.
            const div = document.createElement("div");
            const divStyle = div.style;

            { // 잡다한 스타일 설정
                divStyle.width = "100px";
                divStyle.height = "100px";
                divStyle.color = "white";
                divStyle.backgroundColor = "tomato";

                divStyle.display = "flex";
                divStyle.justifyContent = "center";
                divStyle.alignItems = "center";

                div.textContent = "Click me!";
            }

            document.body.appendChild(div);

            div.addEventListener('click', function () {
                console.log(this); // 클릭시 div element가 출력된다. currentTarget과 같다.
            });
        } {
            // Callback Function
            /*
            JAVASCRIPT 의 함수가 일급객체이기 때문에 가능한 개발 방법이다.
            전달된 함수를 다른 함수가 매개변수로 받아 보관하다가 용무가 있을 때 실행한다.
            */

            const arr = [1,2,3,4,5];
            const entries = [];

            arr.forEach(function (v, i) {
                console.log(v, i, this[i]);
            }, [10, 20, 30, 40, 50]);
            /* 
            forEach를 포함한 map filter 등 일부 배열 내장 메서드들은
            optional한 매개변수로 thisArg를 받는다.
            역시 화살표 함수의 경우 적용이 되지 않는다.
            */

            const obj = {
                val: [5,6,7,8,9],
                printValues: function (v, i) {
                    console.log(this["val"], v); // this["val"] 는 모두 undefined로 평가된다.
                }
            };

            arr.forEach(obj.printValues); // obj.printValues는 메서드로써 전달되지 않는다. printValues라는 함수로써 전달될 뿐.
        }
        {
            // CLOSURE
            // 함수와 선언될 당시의 렉시컬 환경이 결합된 것이다.
            {
                let a = 333;

                const closureFunc = () => {
                    console.log(a);
                }

                closureFunc();
            }

            {
                /*
                outerFunc의 경우 호출시마다 새로운 Lexical Environment를 생성한다.
                그리고 그로 인해 반환되는 새로운 함수는 내부에서 outerLexicalEnvironment로 
                outerFunc 호출시 생성된 Lexical Environment를 참조한다.
                */
                const outerFunc = () => {
                    let b = 1;

                    return () => {
                        console.log(b++);
                    };
                };

                outerFunc()(); // 1
                const returnedFunc = outerFunc();

                /* 
                outerFunc의 실행문맥이 콜스택에서 제거되었음에도 불구하고,
                렉시컬 환경은 반환되는 내부 함수의 참조로 인해 그대로 유지된다.
                자바스크립트 엔진의 최적화에 의해 직접 참조하는 식별자 외의 것은 가비지컬렉터의 수집 대상이 된다.
                */
                returnedFunc(); // 1
                returnedFunc(); // 2
                returnedFunc(); // 3
                returnedFunc(); // 4
            }
        }
    </script>
</body>

</html>