<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>191130 코어 자바스크립트 저자직강</title>
</head>
<body>
    <script>
       {
           // DATA TYPE
           /* 식별자와 데이터의 저장을 별개로 한다.
            식별자에 특정 값을 할당시,
            원시형 데이터의 경우 실제 데이터가 저장된 메모리 주소를 식별자명과 함께 기록한다.
            참조형 데이터의 경우 참조형 데이터의 멤버들의 주소목록이 저장된다.
            */

            // 실행문맥
            /*
            나의 사견 : 
            코어 자바스크립트는 과거 사양을 기준으로 실행문맥을 설명한다.
            식별자 확인에 있어서 과거의 사양과는 큰 변화가 생겼기 때문에,
            과거의 사양을 기준으로 학습할 경우 이후 블록스코프에 대해 이해할 때 혼란이 생길 수 있다.

            예를 들어 지금 이 주석을 작성하고 있는 위치 역시 별개의 블록으로 묶여있다.
            이 블록 스코프에 대해 종전의 사양으로 식별자 확인 작업을 설명하는 것이 가능할까?

            과거에는 함수에 의해서만 새로운 렉시컬 환경이 생성되었지만,
            ES6 이후부터는 try-catch 블록, 블록구문, 반복문의 각 반복단위, 조건문 내 블록 에서 각각 새로운 렉시컬 환경이 생성된다.

            또한 Variable Environment 역시 과거 var로 선언 되었던 식별자들에 대한 하위 호환을 목적으로 만들어진 객체이다.

            이런 큰 차이점들이 있기 때문에,
            보다 실용적이고 최신 스펙에 가까운 개념을 학습코자한다면 http://ko.javascript.info/ 에 정리된 내용을 추천한다.
            
            실행문맥이나 렉시컬 환경은 ECMASCRIPT 사양 상의 개념이기 때문에, 코드내에서 개발자가 직접 접근할 수 있는 실체가 없다.
            물론 과거 프로토타입의 예처럼 향후 스펙에서 어떤 변화가 있을지는 모르겠다만,
            현재는 엔드포인트의 개발자에게 있어서 추상적인 개념일 뿐이므로
            개괄적으로만 코드의 흐름을 읽을 수 있을 정도로 익혀두는 것이 중요하다.
            */

            // THIS
            /*
            THIS BINDING CASE들
                * 전역공간에서 : window/global 전역객체
                * 함수 호출시 : window/global 전역객체
                * 메소드 호출시 : 
                    객체 안에 선언 되거나 저장되어있다고 모두 메서드로써 호출되는 것이 아니다.
                    .연산자나 [] 접근법을 활용시 좌변의 객체를 this로 갖는다. 단, 화살표 함수 예외.
                * callback 호출시 : 렉시컬 환경을 따른다.
                * 생성자 함수 호출시 : 새로 생성된 객체.
                * bind나 call apply 사용시 : 화살표 함수는 동작하지 않고,
                function 선언이나 표현식의 경우에 인자로 전달된 객체를 this로 binding 한다.
            */

            const a = {
                b: {
                    c () {
                        console.log(this);
                    },
                    e: () => {
                        console.log(this);
                    }
                },
                d () {
                    console.log(this);
                }
            };

            const b = a.b;
            
            console.log(
                a.b.c(), // b 객체를 this로 binding
                b.c(), // 상동
                a.d(), // a 객체를 this로 binding
                b.e() // 화살표 함수는 this binding을 하지 않는다. 즉 전역객체가 출력.
            );

            console.log(
                (a.b.c.bind(a))(), // bind는 인자로 받은 객체를 this로 binding한 함수를 반환한다.
                a.d.call(a.b), // 인자로 받은 객체를 this로 binding 하여 호출한다. apply와의 차이점은 this 외의 인자를 배열로 받고 안 받고의 차이일 뿐이다.
            );
       } 
    </script>
</body>
</html>